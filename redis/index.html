<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `redis` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, redis">

    <title>redis - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'redis', ty: 'mod', relpath: '../'};</script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>redis</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-0' class='srclink' href='../src/redis/lib.rs.html#1-361' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>redis-rs is a rust implementation of a Redis client library.  It exposes
a general purpose interface to Redis and also provides specific helpers for
commonly used functionality.</p>

<p>The crate is called <code>redis</code> and you can depend on it via cargo:</p>

<pre><code class="language-ini">[dependencies.redis]
version = &quot;*&quot;
</code></pre>

<p>If you want to use the git version:</p>

<pre><code class="language-ini">[dependencies.redis]
git = &quot;https://github.com/mitsuhiko/redis-rs.git&quot;
</code></pre>

<h1 id="basic-operation" class='section-header'><a
                           href="#basic-operation">Basic Operation</a></h1>
<p>redis-rs exposes to API levels: a low- and a high-level part.  The high-level
part does not expose all the functionality of redis and might take some
liberties in how it speaks the protocol.  The low-level part of the API
allows you to express any request on the redis level.  You can fluently
switch between both API levels at any point.</p>

<h2 id="connection-handling" class='section-header'><a
                           href="#connection-handling">Connection Handling</a></h2>
<p>For connecting to redis you can use a client object which then can produce
actual connections.  Connections and clients as well as results of
connections and clients are considered <code>ConnectionLike</code> objects and
can be used anywhere a request is made.</p>

<p>The full canonical way to get a connection is to create a client and
to ask for a connection from it:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>redis</span>;

<span class='kw'>fn</span> <span class='ident'>do_something</span>() <span class='op'>-&gt;</span> <span class='ident'>redis</span>::<span class='ident'>RedisResult</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>Client</span>::<span class='ident'>open</span>(<span class='string'>&quot;redis://127.0.0.1/&quot;</span>));
    <span class='kw'>let</span> <span class='ident'>con</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>client</span>.<span class='ident'>get_connection</span>());

    <span class='comment'>/* do something here */</span>

    <span class='prelude-val'>Ok</span>(())
}</pre>

<h2 id="unix-sockets" class='section-header'><a
                           href="#unix-sockets">Unix Sockets</a></h2>
<p>By default this library does not support unix sockets but starting with
redis-rs 0.5.0 you can optionally compile it with unix sockets enabled.
For this you just need to enable the <code>unix_sockets</code> flag and some of the
otherwise unavailable APIs become available:</p>

<pre><code class="language-ini">[dependencies.redis]
version = &quot;*&quot;
features = [&quot;unix_socket&quot;]
</code></pre>

<h2 id="connection-parameters" class='section-header'><a
                           href="#connection-parameters">Connection Parameters</a></h2>
<p>redis-rs knows different ways to define where a connection should
go.  The parameter to <code>Client::open</code> needs to implement the
<code>IntoConnectionInfo</code> trait of which there are three implementations:</p>

<ul>
<li>string slices in <code>redis://</code> URL format.</li>
<li>URL objects from the redis-url crate.</li>
<li><code>ConnectionInfo</code> objects.</li>
</ul>

<p>The URL format is <code>redis://[:&lt;passwd&gt;@]&lt;hostname&gt;[:port][/&lt;db&gt;]</code></p>

<p>In case you have compiled the crate with the <code>unix_sockets</code> feature
then you can also use a unix URL in this format:</p>

<p><code>unix:///[:&lt;passwd&gt;@]&lt;path&gt;[?db=&lt;db&gt;]</code></p>

<h2 id="executing-low-level-commands" class='section-header'><a
                           href="#executing-low-level-commands">Executing Low-Level Commands</a></h2>
<p>To execute low-level commands you can use the <code>cmd</code> function which allows
you to build redis requests.  Once you have configured a command object
to your liking you can send a query into any <code>ConnectionLike</code> object:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>con</span>: <span class='kw-2'>&amp;</span><span class='ident'>redis</span>::<span class='ident'>Connection</span>) <span class='op'>-&gt;</span> <span class='ident'>redis</span>::<span class='ident'>RedisResult</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> _ : () <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;my_key&quot;</span>).<span class='ident'>arg</span>(<span class='number'>42</span>).<span class='ident'>query</span>(<span class='ident'>con</span>));
    <span class='prelude-val'>Ok</span>(())
}</pre>

<p>Upon querying the return value is a result object.  If you do not care
about the actual return value (other than that it is not a failure)
you can always type annotate it to the unit type <code>()</code>.</p>

<h2 id="executing-high-level-commands" class='section-header'><a
                           href="#executing-high-level-commands">Executing High-Level Commands</a></h2>
<p>The high-level interface is similar.  For it to become available you
need to use the <code>Commands</code> trait in which case all <code>ConnectionLike</code>
objects the library provides will also have high-level methods which
make working with the protocol easier:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>redis</span>;
<span class='kw'>use</span> <span class='ident'>redis</span>::<span class='ident'>Commands</span>;

<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>con</span>: <span class='kw-2'>&amp;</span><span class='ident'>redis</span>::<span class='ident'>Connection</span>) <span class='op'>-&gt;</span> <span class='ident'>redis</span>::<span class='ident'>RedisResult</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> _ : () <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>set</span>(<span class='string'>&quot;my_key&quot;</span>, <span class='number'>42</span>));
    <span class='prelude-val'>Ok</span>(())
}</pre>

<p>Note that high-level commands are work in progress and many are still
missing!</p>

<h2 id="type-conversions" class='section-header'><a
                           href="#type-conversions">Type Conversions</a></h2>
<p>Because redis inherently is mostly type-less and the protocol is not
exactly friendly to developers, this library provides flexible support
for casting values to the intended results.  This is driven through the
<code>FromRedisValue</code> and <code>ToRedisArgs</code> traits.</p>

<p>The <code>arg</code> method of the command will accept a wide range of types through
the <code>ToRedisArgs</code> trait and the <code>query</code> method of a command can convert the
value to what you expect the function to return through the <code>FromRedisValue</code>
trait.  This is quite flexible and allows vectors, tuples, hashsets, hashmaps
as well as optional values:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>count</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;my_counter&quot;</span>));
<span class='kw'>let</span> <span class='ident'>count</span> <span class='op'>=</span> <span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;my_counter&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='number'>0i32</span>);
<span class='kw'>let</span> <span class='ident'>k</span> : <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;missing_key&quot;</span>));
<span class='kw'>let</span> <span class='ident'>name</span> : <span class='ident'>String</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;my_name&quot;</span>));
<span class='kw'>let</span> <span class='ident'>bin</span> : <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;my_binary&quot;</span>));
<span class='kw'>let</span> <span class='ident'>map</span> : <span class='ident'>HashMap</span><span class='op'>&lt;</span><span class='ident'>String</span>, <span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>hgetall</span>(<span class='string'>&quot;my_hash&quot;</span>));
<span class='kw'>let</span> <span class='ident'>keys</span> : <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>hkeys</span>(<span class='string'>&quot;my_hash&quot;</span>));
<span class='kw'>let</span> <span class='ident'>mems</span> : <span class='ident'>HashSet</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>smembers</span>(<span class='string'>&quot;my_set&quot;</span>));
<span class='kw'>let</span> (<span class='ident'>k1</span>, <span class='ident'>k2</span>) : (<span class='ident'>String</span>, <span class='ident'>String</span>) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;k1&quot;</span>, <span class='string'>&quot;k2&quot;</span>]));</pre>

<h1 id="iteration-protocol" class='section-header'><a
                           href="#iteration-protocol">Iteration Protocol</a></h1>
<p>In addition to sending a single query you iterators are also supported.  When
used with regular bulk responses they don&#39;t give you much over querying and
converting into a vector (both use a vector internally) but they can also
be used with <code>SCAN</code> like commands in which case iteration will send more
queries until the cursor is exhausted:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iter</span> : <span class='ident'>redis</span>::<span class='ident'>Iter</span><span class='op'>&lt;</span><span class='ident'>isize</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>cmd</span>(<span class='string'>&quot;SSCAN&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;my_set&quot;</span>)
    .<span class='ident'>cursor_arg</span>(<span class='number'>0</span>).<span class='ident'>iter</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>iter</span> {
    <span class='comment'>// do something with the item</span>
}</pre>

<p>As you can see the cursor argument needs to be defined with <code>cursor_arg</code>
instead of <code>arg</code> so that the library knows which argument needs updating
as the query is run for more items.</p>

<h1 id="pipelining" class='section-header'><a
                           href="#pipelining">Pipelining</a></h1>
<p>In addition to simple queries you can also send command pipelines.  This
is provided through the <code>pipe</code> function.  It works very similar to sending
individual commands but you can send more than one in one go.  This also
allows you to ignore individual results so that matching on the end result
is easier:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>k1</span>, <span class='ident'>k2</span>) : (<span class='ident'>i32</span>, <span class='ident'>i32</span>) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>pipe</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_1&quot;</span>).<span class='ident'>arg</span>(<span class='number'>42</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>arg</span>(<span class='number'>43</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;GET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_1&quot;</span>)
    .<span class='ident'>cmd</span>(<span class='string'>&quot;GET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>query</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));</pre>

<p>If you want the pipeline to be wrapped in a <code>MULTI</code>/<code>EXEC</code> block you can
easily do that by switching the pipeline into <code>atomic</code> mode.  From the
caller&#39;s point of view nothing changes, the pipeline itself will take
care of the rest for you:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> (<span class='ident'>k1</span>, <span class='ident'>k2</span>) : (<span class='ident'>i32</span>, <span class='ident'>i32</span>) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>pipe</span>()
    .<span class='ident'>atomic</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_1&quot;</span>).<span class='ident'>arg</span>(<span class='number'>42</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>arg</span>(<span class='number'>43</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;GET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_1&quot;</span>)
    .<span class='ident'>cmd</span>(<span class='string'>&quot;GET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>query</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));</pre>

<p>You can also use high-level commands on pipelines through the
<code>PipelineCommands</code> trait:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>redis</span>::<span class='ident'>PipelineCommands</span>;
<span class='kw'>let</span> (<span class='ident'>k1</span>, <span class='ident'>k2</span>) : (<span class='ident'>i32</span>, <span class='ident'>i32</span>) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>pipe</span>()
    .<span class='ident'>atomic</span>()
    .<span class='ident'>set</span>(<span class='string'>&quot;key_1&quot;</span>, <span class='number'>42</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>set</span>(<span class='string'>&quot;key_2&quot;</span>, <span class='number'>43</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>get</span>(<span class='string'>&quot;key_1&quot;</span>)
    .<span class='ident'>get</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>query</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));</pre>

<h1 id="transactions" class='section-header'><a
                           href="#transactions">Transactions</a></h1>
<p>Transactions are available through atomic pipelines.  In order to use
them in a more simple way you can use the <code>transaction</code> function of a
connection:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>redis</span>::{<span class='ident'>Commands</span>, <span class='ident'>PipelineCommands</span>};
<span class='kw'>let</span> <span class='ident'>key</span> <span class='op'>=</span> <span class='string'>&quot;the_key&quot;</span>;
<span class='kw'>let</span> (<span class='ident'>new_val</span>,) : (<span class='ident'>isize</span>,) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>transaction</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>, <span class='kw-2'>&amp;</span>[<span class='ident'>key</span>], <span class='op'>|</span><span class='ident'>pipe</span><span class='op'>|</span> {
    <span class='kw'>let</span> <span class='ident'>old_val</span> : <span class='ident'>isize</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='ident'>key</span>));
    <span class='ident'>pipe</span>
        .<span class='ident'>set</span>(<span class='ident'>key</span>, <span class='ident'>old_val</span> <span class='op'>+</span> <span class='number'>1</span>).<span class='ident'>ignore</span>()
        .<span class='ident'>get</span>(<span class='ident'>key</span>).<span class='ident'>query</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>)
}));
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The incremented number is: {}&quot;</span>, <span class='ident'>new_val</span>);</pre>

<p>For more information see the <code>transaction</code> function.</p>

<h1 id="pubsub" class='section-header'><a
                           href="#pubsub">PubSub</a></h1>
<p>Pubsub is currently work in progress but provided through the <code>PubSub</code>
connection object.  Due to the fact that Rust does not have support
for async IO in libnative yet, the API does not provide a way to
read messages with any form of timeout yet.</p>

<p>Example usage:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>Client</span>::<span class='ident'>open</span>(<span class='string'>&quot;redis://127.0.0.1/&quot;</span>));
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pubsub</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>client</span>.<span class='ident'>get_pubsub</span>());
<span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>pubsub</span>.<span class='ident'>subscribe</span>(<span class='string'>&quot;channel_1&quot;</span>));
<span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>pubsub</span>.<span class='ident'>subscribe</span>(<span class='string'>&quot;channel_2&quot;</span>));

<span class='kw'>loop</span> {
    <span class='kw'>let</span> <span class='ident'>msg</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>pubsub</span>.<span class='ident'>get_message</span>());
    <span class='kw'>let</span> <span class='ident'>payload</span> : <span class='ident'>String</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>msg</span>.<span class='ident'>get_payload</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;channel &#39;{}&#39;: {}&quot;</span>, <span class='ident'>msg</span>.<span class='ident'>get_channel_name</span>(), <span class='ident'>payload</span>);
}</pre>

<h1 id="scripts" class='section-header'><a
                           href="#scripts">Scripts</a></h1>
<p>Lua scripts are supported through the <code>Script</code> type in a convenient
way (it does not support pipelining currently).  It will automatically
load the script if it does not exist and invoke it.</p>

<p>Example:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>script</span> <span class='op'>=</span> <span class='ident'>redis</span>::<span class='ident'>Script</span>::<span class='ident'>new</span>(<span class='string'>r&quot;
    return tonumber(ARGV[1]) + tonumber(ARGV[2]);
&quot;</span>);
<span class='kw'>let</span> <span class='ident'>result</span> : <span class='ident'>isize</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>script</span>.<span class='ident'>arg</span>(<span class='number'>1</span>).<span class='ident'>arg</span>(<span class='number'>2</span>).<span class='ident'>invoke</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>result</span>, <span class='number'>3</span>);</pre>

<h2 id="breaking-changes" class='section-header'><a
                           href="#breaking-changes">Breaking Changes</a></h2>
<p>In Rust 0.5.0 the semi-internal <code>ConnectionInfo</code> struct had to be
changed because of the unix socket support.  You are generally
heavily encouraged to use the URL based configuration format which
is a lot more stable than the structs.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Client.html'
                               title='redis::Client'>Client</a></td>
                        <td class='docblock short'>
                             <p>The client type.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Cmd.html'
                               title='redis::Cmd'>Cmd</a></td>
                        <td class='docblock short'>
                             <p>Represents redis commands.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Connection.html'
                               title='redis::Connection'>Connection</a></td>
                        <td class='docblock short'>
                             <p>Represents a stateful redis TCP connection.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.ConnectionInfo.html'
                               title='redis::ConnectionInfo'>ConnectionInfo</a></td>
                        <td class='docblock short'>
                             <p>Holds the connection information that redis should use for connecting.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.InfoDict.html'
                               title='redis::InfoDict'>InfoDict</a></td>
                        <td class='docblock short'>
                             <p>An info dictionary type.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Iter.html'
                               title='redis::Iter'>Iter</a></td>
                        <td class='docblock short'>
                             <p>Represents a redis iterator.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Msg.html'
                               title='redis::Msg'>Msg</a></td>
                        <td class='docblock short'>
                             <p>Represents a pubsub message.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Parser.html'
                               title='redis::Parser'>Parser</a></td>
                        <td class='docblock short'>
                             <p>The internal redis response parser.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Pipeline.html'
                               title='redis::Pipeline'>Pipeline</a></td>
                        <td class='docblock short'>
                             <p>Represents a redis command pipeline.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.PubSub.html'
                               title='redis::PubSub'>PubSub</a></td>
                        <td class='docblock short'>
                             <p>Represents a pubsub connection.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.RedisError.html'
                               title='redis::RedisError'>RedisError</a></td>
                        <td class='docblock short'>
                             <p>Represents a redis error.  For the most part you should be using
the Error trait to interact with this rather than the actual
struct.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Script.html'
                               title='redis::Script'>Script</a></td>
                        <td class='docblock short'>
                             <p>Represents a lua script.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.ScriptInvocation.html'
                               title='redis::ScriptInvocation'>ScriptInvocation</a></td>
                        <td class='docblock short'>
                             <p>Represents a prepared script call.</p>

                        </td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='enum' href='enum.ConnectionAddr.html'
                               title='redis::ConnectionAddr'>ConnectionAddr</a></td>
                        <td class='docblock short'>
                             
                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='enum' href='enum.ErrorKind.html'
                               title='redis::ErrorKind'>ErrorKind</a></td>
                        <td class='docblock short'>
                             <p>An enum of all error kinds.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='enum' href='enum.NumericBehavior.html'
                               title='redis::NumericBehavior'>NumericBehavior</a></td>
                        <td class='docblock short'>
                             <p>Helper enum that is used in some situations to describe
the behavior of arguments in a numeric context.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='enum' href='enum.Value.html'
                               title='redis::Value'>Value</a></td>
                        <td class='docblock short'>
                             <p>Internal low-level redis value enum.</p>

                        </td>
                    </tr>
                </table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='trait' href='trait.Commands.html'
                               title='redis::Commands'>Commands</a></td>
                        <td class='docblock short'>
                             <p>Implements common redis commands for connection like objects.  This
allows you to send commands straight to a connection or client.  It
is also implemented for redis results of clients which makes for
very convenient access in some basic cases.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='trait' href='trait.ConnectionLike.html'
                               title='redis::ConnectionLike'>ConnectionLike</a></td>
                        <td class='docblock short'>
                             <p>Implements the &quot;stateless&quot; part of the connection interface that is used by the
different objects in redis-rs.  Primarily it obviously applies to <code>Connection</code>
object but also some other objects implement the interface (for instance
whole clients or certain redis results).</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='trait' href='trait.FromRedisValue.html'
                               title='redis::FromRedisValue'>FromRedisValue</a></td>
                        <td class='docblock short'>
                             <p>This trait is used to convert a redis value into a more appropriate
type.  While a redis <code>Value</code> can represent any response that comes
back from the redis server, usually you want to map this into something
that works better in rust.  For instance you might want to convert the
return value into a <code>String</code> or an integer.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='trait' href='trait.IntoConnectionInfo.html'
                               title='redis::IntoConnectionInfo'>IntoConnectionInfo</a></td>
                        <td class='docblock short'>
                             <p>Converts an object into a connection info struct.  This allows the
constructor of the client to accept connection information in a
range of different formats.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='trait' href='trait.PipelineCommands.html'
                               title='redis::PipelineCommands'>PipelineCommands</a></td>
                        <td class='docblock short'>
                             <p>Implements common redis commands for pipelines.  Unlike the regular
commands trait, this returns the pipeline rather than a result
directly.  Other than that it works the same however.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='trait' href='trait.ToRedisArgs.html'
                               title='redis::ToRedisArgs'>ToRedisArgs</a></td>
                        <td class='docblock short'>
                             <p>Used to convert a value into one or multiple redis argument
strings.  Most values will produce exactly one item but in
some cases it might make sense to produce more than one.</p>

                        </td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='fn' href='fn.cmd.html'
                               title='redis::cmd'>cmd</a></td>
                        <td class='docblock short'>
                             <p>Shortcut function to creating a command with a single argument.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='fn' href='fn.from_redis_value.html'
                               title='redis::from_redis_value'>from_redis_value</a></td>
                        <td class='docblock short'>
                             <p>A shortcut function to invoke <code>FromRedisValue::from_redis_value</code>
to make the API slightly nicer.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='fn' href='fn.pack_command.html'
                               title='redis::pack_command'>pack_command</a></td>
                        <td class='docblock short'>
                             <p>Packs a bunch of commands into a request.  This is generally a quite
useless function as this functionality is nicely wrapped through the
<code>Cmd</code> object, but in some cases it can be useful.  The return value
of this can then be send to the low level <code>ConnectionLike</code> methods.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='fn' href='fn.parse_redis_url.html'
                               title='redis::parse_redis_url'>parse_redis_url</a></td>
                        <td class='docblock short'>
                             <p>This function takes a redis URL string and parses it into a URL
as used by rust-url.  This is necessary as the default parser does
not understand how redis URLs function.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='fn' href='fn.parse_redis_value.html'
                               title='redis::parse_redis_value'>parse_redis_value</a></td>
                        <td class='docblock short'>
                             <p>Parses bytes into a redis value.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='fn' href='fn.pipe.html'
                               title='redis::pipe'>pipe</a></td>
                        <td class='docblock short'>
                             <p>Shortcut for creating a new pipeline.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='fn' href='fn.transaction.html'
                               title='redis::transaction'>transaction</a></td>
                        <td class='docblock short'>
                             <p>This function simplifies transaction management slightly.  What it
does is automatically watching keys and then going into a transaction
loop util it succeeds.  Once it goes through the results are
returned.</p>

                        </td>
                    </tr>
                </table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='type' href='type.RedisResult.html'
                               title='redis::RedisResult'>RedisResult</a></td>
                        <td class='docblock short'>
                             <p>Library generic result type.</p>

                        </td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div>
            <div class="shortcuts">
                <h1>Keyboard Shortcuts</h1>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h1>Search Tricks</h1>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "redis";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>